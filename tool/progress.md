# Object files
Generated by the Make file on the repository, tried to keep the same compilation flags but some were giving error. Check the keil flangs and make file to determine the missing.

**startup_SSE310MPS3.c file is modified as *__set_MSPLIM* and *__set_PSPLIM* function were not recognized during compilation**



# Linking Object files:
1. Relace object files in Keil IDE with generated file from the previous step. **Could not find any command line option or linking option in Keil**

2. Link with gcc tool chain provided by ARM. Curretly getting errors of undefined reference. For linking stage also not all linker flags are included because of error. **Current command after running Make file:** ../../m85-toolchain/arm-gnu-toolchain-12.2.mpacbti-bet1-x86_64-arm-none-eabi/bin/arm-none-eabi-gcc -march=armv8.1-m.main -mcpu=Cortex-M85 -mfloat-abi=hard -mfpu=fpv5-d16 *.o -callgraph -o Blinky.axf -T linker_SSE310MPS3_secure.ld

3. Linking with clang is also failing: **Command:** clang -march=armv8.1-m.main -mcpu=Cortex-M85 -mfloat-abi=hard -mfpu=fpv5-d16 *.o -o Blinky.axf -T linker_SSE310MPS3_secure.ld 

# Build from source with ARM LLVM tool chain
We will be using the LLVM arm tool chain version 16.0.0, Link: https://github.com/ARM-software/LLVM-embedded-toolchain-for-Arm/tree/llvm-16
Follow the readme file and build from source markup files. Run the below commands to configure the environment.
The [generate_version_txt.cmake] (https://github.com/CactiLab/code-CFA-with-pac/LLVM_compiler/Environment-config/generate_version_txt.cmake) file has some issues when dowlaoded from release, We need to replace that file in directory: LLVM-embedded-toolchain-for-Arm-release-16.0.0/cmake

1. mkdir repos
2. git -C repos clone --branch llvmorg-16.0.0 https://github.com/llvm/llvm-project.git
3. git -C repos/llvm-project apply ../../patches/llvm-project.patch
4. git -C repos clone https://github.com/picolibc/picolibc.git && git -C repos/picolibc checkout 35c504ff6065b2a87ea8a106ae0d0d61d1e7ece5
5. git -C repos/picolibc apply ../../patches/picolibc.patch
6. mkdir build
7. cd build
8. cmake .. -GNinja -DFETCHCONTENT_SOURCE_DIR_LLVMPROJECT=../repos/llvm-project -DFETCHCONTENT_SOURCE_DIR_PICOLIBC=../repos/picolibc
9. ninja

# LLVM tool chain info
1. front end pass library directory after build: /home/tomal/llvm_all/llvm-arm-org/LLVM-embedded-toolchain-for-Arm-release-17.0.1/build/llvm/lib


# LLVM Tool commands
*LLVM object dump form cortex-m85 with pacbti:* `llvm-objdump --arch-name=arm --mcpu=cortex-m85 --mattr=+pacbti -d outm_passARM16.o`

# Back-end runtime test results:
- [x] pacg instructions are present in the binary
- [x] We can run the binary and execute the pacg instruction for the application function
- [x] `vprintf` function contains `r12` register uses thats why its changing the value of `r12`
- []  Need to verify all instrumentations Mb and Mf
- [x] Found that the generated object file sometimes miss a pacg instruction. Why? <br/>
    For example: there should be a `pacg	r10, pc, r10` instruction before the marked line in the disassembly code. <br/>
    110002a8 \<mod2\>:<br/>
    110002a8: b580    &nbsp;     	push	{r7, lr} <br/>
    110002aa: 466f   &nbsp;      	mov	r7, sp  <br/>
    110002ac: b082    &nbsp;     	sub	sp, #0x8  <br/>
    110002ae: 9000     &nbsp;    	str	r0, [sp]  <br/>
    110002b0: 9800     &nbsp;    	ldr	r0, [sp]  <br/>
    110002b2: eb00 71d0  &nbsp;  	add.w	r1, r0, r0, lsr #31 <br/>
    110002b6: f021 0101  &nbsp;  	bic	r1, r1, #0x1 <br/>
    110002ba: 1a40      &nbsp;   	subs	r0, r0, r1 <br/>
    110002bc: b928     &nbsp;    	cbnz	r0, 0x110002ca <mod2+0x22> @ imm = #0xa <br/>
    110002be: e7ff    &nbsp;     	b	0x110002c0 <mod2+0x18>  @ imm = #-0x2 <br/>
    `110002c0: f001 f98a   &nbsp; 	bl	0x110015d8 <secure_trace_storage> @ imm = #0x1314` <br/>
    110002c4: 9800      &nbsp;   	ldr	r0, [sp] <br/>
    110002c6: 9001     &nbsp;    	str	r0, [sp, #0x4] <br/>
    110002c8: e007     &nbsp;    	b	0x110002da <mod2+0x32>  @ imm = #0xe <br/>
    110002ca: fb6f fa0a  &nbsp;  	pacg	r10, pc, r10 <br/>
    110002ce: f001 f983   &nbsp; 	bl	0x110015d8 <secure_trace_storage> @ imm = #0x1306 <br/>
    110002d2: 9800     &nbsp;    	ldr	r0, [sp] <br/>
    110002d4: 3001     &nbsp;    	adds	r0, #0x1
    110002d6: 9001     &nbsp;    	str	r0, [sp, #0x4] <br/>
    110002d8: e7ff    &nbsp;     	b	0x110002da <mod2+0x32>  @ imm = #-0x2 <br/>
    110002da: 9801    &nbsp;     	ldr	r0, [sp, #0x4] <br/>
    110002dc: b002    &nbsp;     	add	sp, #0x8 <br/>
    110002de: fb6e fc0c  &nbsp;   	pacg	r12, lr, r12 <br/>
    110002e2: bd80     &nbsp;    	pop	{r7, pc} <br/>
     <br/>
    Below the is the corresponding assembly code generated by `llc`:  <br/>
    
     mod2:  <br/>
	.fnstart  <br/>
\@ %bb.0:  <br/>
	push	{r11, lr}  <br/>
	mov	r11, sp  <br/>
	sub	sp, sp, #8  <br/>
	str	r0, [sp]  <br/>
	ldr	r0, [sp]  <br/>
	add	r1, r0, r0, lsr #31  <br/>
	bic	r1, r1, #1  <br/>
	sub	r0, r0, r1  <br/>
	cmp	r0, #0  <br/>
	bne	.LBB0_2  <br/>
	b	.LBB0_1  <br/>
.LBB0_1:  <br/>
	`pacg	r10, pc, r10`  <br/>
	bl	secure_trace_storage  <br/>
	mov	r0, #0  <br/>
	str	r0, [sp, #4]  <br/>
	b	.LBB0_3  <br/>
.LBB0_2:  <br/>
	pacg	r10, pc, r10  <br/>
	bl	secure_trace_storage  <br/>
	mov	r0, #1  <br/>
	str	r0, [sp, #4]  <br/>
	b	.LBB0_3  <br/>
.LBB0_3:  <br/>
	ldr	r0, [sp, #4]  <br/>
	mov	sp, r11  <br/>
	pop	{r11, lr}  <br/>
	pacg	r12, lr, r12  <br/>
	mov	pc, lr <br/>
    * If we compile the C file with clang using make file CFLAGS we are facing this issue in assembly too. It converts the `cbnz` instruction to a direct branch, thus not considered by llvm back-end conditional branch instruction.
    * but with this flangs back-end can not identify trampoline functions with name. - [x]
    * tried with metadata- not available at machine instruction level -[x] 
    * tried making trampline functions as external still can not identify - [x]
    * check clang flags, why adding flags stops identifying function names at back-end -[x]
    * Solution: solved function call name identification issue in back-end: after changing the flangs the architecture is different, thus we need to check all operands of call instruction (Commit message: `solved- missing pacg instrumentation for forward edge`)
- [] verify the instrumentation offline first, 1. generate the assembly and compare 2. Debug line by line at runtime.
- [] Need to check library compilation tools to stop using the `r12` registers?